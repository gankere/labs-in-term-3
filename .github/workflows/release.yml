name: 'C++ CI'

on:
  push:
    branches: [ 'lab*' ]  # Срабатывает на любую ветку, начинающуюся с "lab"

permissions:
  contents: write  # Для тегов и релизов

jobs:
  bump_version:
    runs-on: ubuntu-latest
    outputs:
      new_tag: ${{ steps.bump.outputs.new_tag }}
      major: ${{ steps.bump.outputs.major }}
      minor: ${{ steps.bump.outputs.minor }}
      patch: ${{ steps.bump.outputs.patch }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Patch version
        id: bump
        shell: bash
        run: |
          unset new_tag major minor patch last_tag

          git fetch --tags --quiet

          # Берём последний семантический тег (vX.Y.Z)
          last_tag=$(git tag --list 'v[0-9]*.[0-9]*.[0-9]*' --sort=-version:refname | head -n1)
          if [ -z "$last_tag" ]; then
            last_tag="v1.0.0"
          fi
          last_tag=${last_tag#v}

          IFS='.' read -r major minor patch <<< "$last_tag"

          while true; do
            patch=$((patch+1))
            new_tag="$major.$minor.$patch"

            # Проверка: тег должен состоять только из цифр и точек
            if ! [[ "$new_tag" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
              echo "ERROR: Invalid tag format: '$new_tag'" >&2
              exit 1
            fi

            # Проверяем, что тег ещё не существует
            if git rev-parse -q --verify "refs/tags/$new_tag" >/dev/null 2>&1; then
              echo "Tag '$new_tag' already exists locally, skipping..."
              continue
            fi
            if git ls-remote --tags origin "refs/tags/$new_tag" | grep -q "$new_tag"; then
              echo "Tag '$new_tag' already exists remotely, skipping..."
              continue
            fi

            echo "✅ Creating tag: $new_tag"
            git tag "$new_tag"
            git push origin "refs/tags/$new_tag"
            echo "new_tag=$new_tag" >> "$GITHUB_OUTPUT"
            echo "major=$major" >> "$GITHUB_OUTPUT"
            echo "minor=$minor" >> "$GITHUB_OUTPUT"
            echo "patch=$patch" >> "$GITHUB_OUTPUT"
            break
          done
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  build_and_package:
    needs: bump_version
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest]
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          submodules: recursive  # Если у вас есть подмодули

      - name: Install Ninja (Windows)
        if: runner.os == 'Windows'
        run: choco install ninja -y

      - name: Install Ninja (Linux)
        if: runner.os == 'Linux'
        run: sudo apt-get update && sudo apt-get install -y ninja-build

      - name: Configure with Ninja
        run: |
          cmake -G "Ninja" -S . -B build \
            -DPROJECT_VERSION_MAJOR=${{ needs.bump_version.outputs.major }} \
            -DPROJECT_VERSION_MINOR=${{ needs.bump_version.outputs.minor }} \
            -DPATCH_VERSION=${{ needs.bump_version.outputs.patch }}

      - name: Build with Ninja
        run: cmake --build build

      - name: Run check
        run: |
          if [[ "${{ runner.os }}" == "Windows" ]]; then
            ./build/lab2.exe
          else
            ./build/lab2
          fi

      - name: Run tests
        run: |
          if [[ "${{ runner.os }}" == "Windows" ]]; then
            ./build/gtest_tests/GTestTests.exe
          else
            ./build/gtest_tests/GTestTests
          fi

      - name: Package
        run: |
          cmake --install build --prefix package \
          && if [[ "${{ runner.os }}" == "Windows" ]]; then
               cpack -G ZIP --config build/CPackConfig.cmake;
             else
               cpack -G DEB --config build/CPackConfig.cmake;
             fi

      - name: Upload
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ needs.bump_version.outputs.new_tag }}
          files: build/package/*
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}